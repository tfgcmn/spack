diff --git a/CMakeLists.txt b/CMakeLists.txt
index cc03e39d42..924f0a486e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1397,6 +1397,7 @@ if(ENABLE_PLUGINS)
 	set(PLUGIN_SRC_DIRS
 		plugins/epan/ethercat
 		plugins/epan/gryphon
+		plugins/epan/hostarq
 		plugins/epan/irda
 		plugins/epan/mate
 		plugins/epan/opcua
diff --git a/configure.ac b/configure.ac
index 8422102121..8892a80b43 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2831,6 +2831,7 @@ AC_CONFIG_FILES(
   plugins/Makefile
   plugins/epan/ethercat/Makefile
   plugins/epan/gryphon/Makefile
+  plugins/epan/hostarq/Makefile
   plugins/epan/irda/Makefile
   plugins/epan/mate/Makefile
   plugins/epan/opcua/Makefile
diff --git a/hmf-wireshark/.gitignore b/hmf-wireshark/.gitignore
new file mode 100644
index 0000000000..c7478fe7d1
--- /dev/null
+++ b/hmf-wireshark/.gitignore
@@ -0,0 +1,5 @@
+.deps/
+.libs/
+*.la
+*.lo
+*.o
diff --git a/hmf-wireshark/AUTHORS b/hmf-wireshark/AUTHORS
new file mode 100644
index 0000000000..bc80bf18d6
--- /dev/null
+++ b/hmf-wireshark/AUTHORS
@@ -0,0 +1,2 @@
+Author :
+Eric Müller <mueller@kip.uni-heidelberg.de>
diff --git a/hmf-wireshark/CMakeLists.txt b/hmf-wireshark/CMakeLists.txt
new file mode 100644
index 0000000000..9e0aad9269
--- /dev/null
+++ b/hmf-wireshark/CMakeLists.txt
@@ -0,0 +1,65 @@
+# CMakeLists.txt
+#
+# $Id: CMakeLists.txt 34243 2010-09-24 20:41:34Z guy $
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+
+set(DISSECTOR_SRC
+	packet-hostarq.c
+)
+
+set(PLUGIN_FILES
+	plugin.c
+	${DISSECTOR_SRC}
+)
+
+set(CLEAN_FILES
+	${PLUGIN_FILES}
+)
+
+if (WERROR)
+	set_source_files_properties(
+		${CLEAN_FILES}
+		PROPERTIES
+		COMPILE_FLAGS -Werror
+	)
+endif()
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+
+register_dissector_files(plugin.c
+	plugin
+	${DISSECTOR_SRC}
+)
+
+add_library(hostarq ${LINK_MODE_MODULE}
+	${PLUGIN_FILES}
+)
+set_target_properties(hostarq PROPERTIES PREFIX "")
+set_target_properties(hostarq PROPERTIES LINK_FLAGS "${WS_LINK_FLAGS}")
+
+target_link_libraries(hostarq epan)
+
+install(TARGETS hostarq
+	LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/@CPACK_PACKAGE_NAME@/plugins/${CPACK_PACKAGE_VERSION} NAMELINK_SKIP
+	RUNTIME DESTINATION ${CMAKE_INSTALL_LIBDIR}/@CPACK_PACKAGE_NAME@/plugins/${CPACK_PACKAGE_VERSION}
+	ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}/@CPACK_PACKAGE_NAME@/plugins/${CPACK_PACKAGE_VERSION}
+)
+
diff --git a/hmf-wireshark/COPYING b/hmf-wireshark/COPYING
new file mode 100644
index 0000000000..d60c31a97a
--- /dev/null
+++ b/hmf-wireshark/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/hmf-wireshark/ChangeLog b/hmf-wireshark/ChangeLog
new file mode 100644
index 0000000000..0986b7c6ee
--- /dev/null
+++ b/hmf-wireshark/ChangeLog
@@ -0,0 +1,2 @@
+Initial Implementation
+2014-06-20
diff --git a/hmf-wireshark/Makefile.am b/hmf-wireshark/Makefile.am
new file mode 100644
index 0000000000..bb35c7f5ee
--- /dev/null
+++ b/hmf-wireshark/Makefile.am
@@ -0,0 +1,129 @@
+# Makefile.am
+# Automake file for HostARQ & NMPM1 FCP plugin
+# By Eric Müller <mueller@kip.uni-heidelberg.de>
+# Copyright 2014 Eric Müller
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+
+INCLUDES = -I$(top_srcdir) -I$(includedir)
+
+include Makefile.common
+
+if HAVE_WARNINGS_AS_ERRORS
+AM_CFLAGS = -Werror
+endif
+
+plugindir = @plugindir@
+
+plugin_LTLIBRARIES = hostarq.la
+hostarq_la_SOURCES = \
+	plugin.c \
+	moduleinfo.h \
+	$(DISSECTOR_SRC) \
+	$(DISSECTOR_SUPPORT_SRC) \
+	$(DISSECTOR_INCLUDES)
+hostarq_la_LDFLAGS = -module -avoid-version
+hostarq_la_LIBADD = @PLUGIN_LIBS@
+
+# Libs must be cleared, or else libtool won't create a shared module.
+# If your module needs to be linked against any particular libraries,
+# add them here.
+LIBS =
+
+#
+# Build plugin.c, which contains the plugin version[] string, a
+# function plugin_register() that calls the register routines for all
+# protocols, and a function plugin_reg_handoff() that calls the handoff
+# registration routines for all protocols.
+#
+# We do this by scanning sources.  If that turns out to be too slow,
+# maybe we could just require every .o file to have an register routine
+# of a given name (packet-aarp.o -> proto_register_aarp, etc.).
+#
+# Formatting conventions:  The name of the proto_register_* routines an
+# proto_reg_handoff_* routines must start in column zero, or must be
+# preceded only by "void " starting in column zero, and must not be
+# inside #if.
+#
+# DISSECTOR_SRC is assumed to have all the files that need to be scanned.
+#
+# For some unknown reason, having a big "for" loop in the Makefile
+# to scan all the files doesn't work with some "make"s; they seem to
+# pass only the first few names in the list to the shell, for some
+# reason.
+#
+# Therefore, we have a script to generate the plugin.c file.
+# The shell script runs slowly, as multiple greps and seds are run
+# for each input file; this is especially slow on Windows.  Therefore,
+# if Python is present (as indicated by PYTHON being defined), we run
+# a faster Python script to do that work instead.
+#
+# The first argument is the directory in which the source files live.
+# The second argument is "plugin", to indicate that we should build
+# a plugin.c file for a plugin.
+# All subsequent arguments are the files to scan.
+#
+plugin.c: $(DISSECTOR_SRC) Makefile.common $(top_srcdir)/tools/make-dissector-reg \
+    $(top_srcdir)/tools/make-dissector-reg.py
+	@if test -n "$(PYTHON)"; then \
+		echo Making plugin.c with python ; \
+		$(PYTHON) $(top_srcdir)/tools/make-dissector-reg.py $(srcdir) \
+		    plugin $(DISSECTOR_SRC) ; \
+	else \
+		echo Making plugin.c with shell script ; \
+		$(top_srcdir)/tools/make-dissector-reg $(srcdir) \
+		    $(plugin_src) plugin $(DISSECTOR_SRC) ; \
+	fi
+
+#
+# Currently plugin.c can be included in the distribution because
+# we always build all protocol dissectors. We used to have to check
+# whether or not to build the snmp dissector. If we again need to
+# variably build something, making plugin.c non-portable, uncomment
+# the dist-hook line below.
+#
+# Oh, yuk.  We don't want to include "plugin.c" in the distribution, as
+# its contents depend on the configuration, and therefore we want it
+# to be built when the first "make" is done; however, Automake insists
+# on putting *all* source into the distribution.
+#
+# We work around this by having a "dist-hook" rule that deletes
+# "plugin.c", so that "dist" won't pick it up.
+#
+#dist-hook:
+#	@rm -f $(distdir)/plugin.c
+
+CLEANFILES = \
+	hostarq \
+	*~
+
+MAINTAINERCLEANFILES = \
+	Makefile.in	\
+	plugin.c
+
+EXTRA_DIST = \
+	Makefile.common		\
+	Makefile.nmake		\
+	moduleinfo.nmake	\
+	plugin.rc.in		\
+	CMakeLists.txt
+
+checkapi:
+	$(PERL) $(top_srcdir)/tools/checkAPIs.pl -g abort -g termoutput -build $(DISSECTOR_SRC) $(DISSECTOR_INCLUDES)
diff --git a/hmf-wireshark/Makefile.common b/hmf-wireshark/Makefile.common
new file mode 100644
index 0000000000..d56bb43d7e
--- /dev/null
+++ b/hmf-wireshark/Makefile.common
@@ -0,0 +1,38 @@
+# Makefile.common for HostARQ & NMPM1 FCP plugin
+#     Contains the stuff from Makefile.am and Makefile.nmake that is
+#     a) common to both files and
+#     b) portable between both files
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+# the name of the plugin
+PLUGIN_NAME = hostarq
+
+# the dissector sources (without any helpers)
+DISSECTOR_SRC = \
+	packet-hostarq.c
+
+# corresponding headers
+DISSECTOR_INCLUDES =	\
+	packet-hostarq.h
+
+# Dissector helpers. They're included in the source files in this
+# directory, but they're not dissectors themselves, i.e. they're not
+# used to generate "plugin.c".
+DISSECTOR_SUPPORT_SRC =
diff --git a/hmf-wireshark/Makefile.nmake b/hmf-wireshark/Makefile.nmake
new file mode 100644
index 0000000000..deacd63862
--- /dev/null
+++ b/hmf-wireshark/Makefile.nmake
@@ -0,0 +1,104 @@
+# Makefile.nmake
+# nmake file for Wireshark plugin
+#
+# $Id: Makefile.nmake 42971 2012-06-01 14:08:12Z wmeier $
+#
+
+include ..\..\config.nmake
+include moduleinfo.nmake
+
+include Makefile.common
+
+CFLAGS=$(WARNINGS_ARE_ERRORS) $(STANDARD_CFLAGS) \
+	/I../.. $(GLIB_CFLAGS) \
+	/I$(PCAP_DIR)\include
+
+.c.obj::
+	$(CC) $(CFLAGS) -Fd.\ -c $<
+
+LDFLAGS = $(PLUGIN_LDFLAGS)
+
+!IFDEF ENABLE_LIBWIRESHARK
+LINK_PLUGIN_WITH=..\..\epan\libwireshark.lib
+CFLAGS=/D_NEED_VAR_IMPORT_ $(CFLAGS)
+
+DISSECTOR_OBJECTS = $(DISSECTOR_SRC:.c=.obj)
+
+DISSECTOR_SUPPORT_OBJECTS = $(DISSECTOR_SUPPORT_SRC:.c=.obj)
+
+OBJECTS = $(DISSECTOR_OBJECTS) $(DISSECTOR_SUPPORT_OBJECTS) plugin.obj
+
+RESOURCE=$(PLUGIN_NAME).res
+
+all: $(PLUGIN_NAME).dll
+
+$(PLUGIN_NAME).rc : moduleinfo.nmake
+	sed -e s/@PLUGIN_NAME@/$(PLUGIN_NAME)/ \
+	-e s/@RC_MODULE_VERSION@/$(RC_MODULE_VERSION)/ \
+	-e s/@RC_VERSION@/$(RC_VERSION)/ \
+	-e s/@MODULE_VERSION@/$(MODULE_VERSION)/ \
+	-e s/@PACKAGE@/$(PACKAGE)/ \
+	-e s/@VERSION@/$(VERSION)/ \
+	-e s/@MSVC_VARIANT@/$(MSVC_VARIANT)/ \
+	< plugin.rc.in > $@
+
+$(PLUGIN_NAME).dll $(PLUGIN_NAME).exp $(PLUGIN_NAME).lib : $(OBJECTS) $(LINK_PLUGIN_WITH) $(RESOURCE)
+	link -dll /out:$(PLUGIN_NAME).dll $(LDFLAGS) $(OBJECTS) $(LINK_PLUGIN_WITH) \
+	$(GLIB_LIBS) $(RESOURCE)
+
+#
+# Build plugin.c, which contains the plugin version[] string, a
+# function plugin_register() that calls the register routines for all
+# protocols, and a function plugin_reg_handoff() that calls the handoff
+# registration routines for all protocols.
+#
+# We do this by scanning sources.  If that turns out to be too slow,
+# maybe we could just require every .o file to have an register routine
+# of a given name (packet-aarp.o -> proto_register_aarp, etc.).
+#
+# Formatting conventions:  The name of the proto_register_* routines an
+# proto_reg_handoff_* routines must start in column zero, or must be
+# preceded only by "void " starting in column zero, and must not be
+# inside #if.
+#
+# DISSECTOR_SRC is assumed to have all the files that need to be scanned.
+#
+# For some unknown reason, having a big "for" loop in the Makefile
+# to scan all the files doesn't work with some "make"s; they seem to
+# pass only the first few names in the list to the shell, for some
+# reason.
+#
+# Therefore, we have a script to generate the plugin.c file.
+# The shell script runs slowly, as multiple greps and seds are run
+# for each input file; this is especially slow on Windows.  Therefore,
+# if Python is present (as indicated by PYTHON being defined), we run
+# a faster Python script to do that work instead.
+#
+# The first argument is the directory in which the source files live.
+# The second argument is "plugin", to indicate that we should build
+# a plugin.c file for a plugin.
+# All subsequent arguments are the files to scan.
+#
+!IFDEF PYTHON
+plugin.c: $(DISSECTOR_SRC) moduleinfo.h Makefile.common ../../tools/make-dissector-reg.py
+	@echo Making plugin.c (using python)
+	@$(PYTHON) "../../tools/make-dissector-reg.py" . plugin $(DISSECTOR_SRC)
+!ELSE
+plugin.c: $(DISSECTOR_SRC) moduleinfo.h Makefile.common ../../tools/make-dissector-reg
+	@echo Making plugin.c (using sh)
+	@$(SH) ../../tools/make-dissector-reg . plugin $(DISSECTOR_SRC)
+!ENDIF
+
+!ENDIF
+
+clean:
+	rm -f $(OBJECTS) $(RESOURCE) plugin.c *.pdb *.sbr \
+	    $(PLUGIN_NAME).dll $(PLUGIN_NAME).dll.manifest $(PLUGIN_NAME).lib \
+	    $(PLUGIN_NAME).exp $(PLUGIN_NAME).rc
+
+distclean: clean
+
+maintainer-clean: distclean
+
+checkapi:
+	$(PERL) ../../tools/checkAPIs.pl -g abort -g termoutput -build $(DISSECTOR_SRC) $(DISSECTOR_INCLUDES)
diff --git a/hmf-wireshark/README.md b/hmf-wireshark/README.md
new file mode 100644
index 0000000000..58bd584490
--- /dev/null
+++ b/hmf-wireshark/README.md
@@ -0,0 +1,24 @@
+Wireshark Dissector for NMPM FCP Communication
+==============================================
+
+A Wireshark Plugin for Dissection of HBP/NMPM Communication.
+
+Tested on Debian wheezy's wireshark 1.8.2.
+
+
+Building
+--------
+    $ apt-get source wireshark/wheezy
+    $ cd wireshark-1.8.2/plugins
+    $ git clone https://github.com/muffgaga/wireshark-dissector-nmpmfcp.git hostarq
+    # add "hostarq" to @SUBDIRS@ variable in plugins/Makefile.am
+    # add "plugins/hostarq/Makefile" to "AC_OUTPUT" in configure.ac
+    $ ./autogen.sh
+    $ ./configure
+    $ make
+
+
+Edit-Test Cycle
+---------------
+    $ make -C plugins
+    $ WIRESHARK_RUN_FROM_BUILD_DIRECTORY=1 ./wireshark
diff --git a/hmf-wireshark/moduleinfo.h b/hmf-wireshark/moduleinfo.h
new file mode 100644
index 0000000000..987dfce522
--- /dev/null
+++ b/hmf-wireshark/moduleinfo.h
@@ -0,0 +1,16 @@
+/* Included *after* config.h, in order to re-define these macros */
+
+#ifdef PACKAGE
+#undef PACKAGE
+#endif
+
+/* Name of package */
+#define PACKAGE "hostarq"
+
+
+#ifdef VERSION
+#undef VERSION
+#endif
+
+/* Version number of package */
+#define VERSION "0.0.1"
diff --git a/hmf-wireshark/moduleinfo.nmake b/hmf-wireshark/moduleinfo.nmake
new file mode 100644
index 0000000000..378e15ca3b
--- /dev/null
+++ b/hmf-wireshark/moduleinfo.nmake
@@ -0,0 +1,27 @@
+#
+#
+
+# The name
+PACKAGE=hostarq
+
+# The version
+MODULE_VERSION_MAJOR=0
+MODULE_VERSION_MINOR=0
+MODULE_VERSION_MICRO=1
+MODULE_VERSION_EXTRA=0
+
+#
+# The RC_VERSION should be comma-separated, not dot-separated, 
+# as per Graham Bloice's message in
+#
+#	http://www.ethereal.com/lists/ethereal-dev/200303/msg00283.html
+#
+# "The RC_VERSION variable in config.nmake should be comma separated. 
+# This allows the resources to be built correctly and the version
+# number to be correctly displayed in the explorer properties dialog
+# for the executables, and XP's tooltip, rather than 0.0.0.0."
+#
+
+MODULE_VERSION=$(MODULE_VERSION_MAJOR).$(MODULE_VERSION_MINOR).$(MODULE_VERSION_MICRO).$(MODULE_VERSION_EXTRA)
+RC_MODULE_VERSION=$(MODULE_VERSION_MAJOR),$(MODULE_VERSION_MINOR),$(MODULE_VERSION_MICRO),$(MODULE_VERSION_EXTRA)
+
diff --git a/hmf-wireshark/packet-hostarq.c b/hmf-wireshark/packet-hostarq.c
new file mode 100644
index 0000000000..b5a2adc4b2
--- /dev/null
+++ b/hmf-wireshark/packet-hostarq.c
@@ -0,0 +1,852 @@
+/* packet-hostarq.c
+ * Routines for HostARQ protocol packet disassembly
+ * By Eric Müller <mueller@kip.uni-heidelberg.de>
+ * Copyright 2014 Eric Müller
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <glib.h>
+#include <epan/packet.h>
+#include <epan/dissectors/packet-udp.h>
+#include <epan/prefs.h>
+#include "packet-hostarq.h"
+
+#define HOSTARQ_PORT 1234
+
+#define HOSTARQ_LOOP 0x8001
+#define HOSTARQ_CFG  0x8002
+
+#define JTAGBULK     0x0C33
+#define JTAGSINGLE   0x0C3A
+#define I2C          0x0CCC
+#define FPGATRACE    0x0CA5
+#define HICANNREAD   0x0CA3
+#define FPGAPLAYBACK 0x0C5A
+#define FPGAROUTING  0x0CAA
+#define FPGACONFIG   0x0C1B
+#define FPGABWLIMIT  0x0DB0
+#define DNCROUTING   0x1364
+#define DNCCONFIG    0x1361
+#define HICANNCONFIG 0x2A1B
+
+static const value_string pdutypenames[] = {
+	// copied from host_al_controller.h
+	{ JTAGBULK,     "JTAGBULK" },
+	{ JTAGSINGLE,   "JTAGSINGLE" },
+	{ HOSTARQ_CFG,  "HOSTARQ_CFG" },
+	{ HOSTARQ_LOOP, "HOSTARQ_LOOP" },
+	{ I2C,          "I2C" },
+	{ FPGATRACE,    "FPGATRACE" },
+	{ HICANNREAD,   "HICANNREAD" },
+	{ FPGAPLAYBACK, "FPGAPLAYBACK" },
+	{ FPGAROUTING,  "FPGAROUTING" },
+	{ FPGACONFIG,   "FPGACONFIG" },
+	{ FPGABWLIMIT,  "FPGABWLIMIT" },
+	{ DNCROUTING,   "DNCROUTING" },
+	{ DNCCONFIG,    "DNCCONFIG" },
+	{ HICANNCONFIG, "HICANNCONFIG" },
+	{ 0, NULL}
+};
+
+static int proto_hostarq = -1;
+
+static int hf_hostarq_pdu_ack = -1;
+static int hf_hostarq_pdu_seq = -1;
+static int hf_hostarq_pdu_valid = -1;
+static int hf_hostarq_pdu_type = -1;
+static int hf_hostarq_pdu_len = -1;
+
+static gint ett_hostarq = -1;
+
+static dissector_table_t hostarq_dissector_table = NULL;
+
+static const value_string packettypenames[] = {
+	{ 0,          "ACK"  },
+	{ 1,          "DATA" },
+	{ 0xffffffff, "DATA" }
+};
+
+void
+proto_register_hostarq(void)
+{
+	static hf_register_info hf[] = {
+		{ &hf_hostarq_pdu_ack,
+			{ "HostARQ PDU Acknowledge", "hostarq.ack",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_hostarq_pdu_seq,
+			{ "HostARQ PDU Sequence", "hostarq.seq",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		}/*,
+		{ &hf_hostarq_pdu_valid,
+			{ "HostARQ PDU Valid", "hostarq.valid",
+				FT_UINT32, BASE_HEX,
+				VALS(packettypenames), 0x0,
+				NULL, HFILL }
+		} */
+	};
+
+	/* Setup protocol subtree array */
+	static gint *ett[] = {
+		&ett_hostarq
+	};
+
+	proto_hostarq = proto_register_protocol (
+		"HostARQ Protocol", /* name       */
+		"HostARQ",          /* short name */
+		"hostarq"           /* abbrev     */
+	);
+
+	proto_register_field_array(proto_hostarq, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+}
+
+void
+proto_reg_handoff_hostarq(void)
+{
+	static dissector_handle_t hostarq_handle;
+
+	hostarq_handle = create_dissector_handle(dissect_hostarq, proto_hostarq);
+	dissector_add_uint("udp.port", HOSTARQ_PORT, hostarq_handle);
+}
+
+static void
+dissect_hostarq(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+	gint offset = 0;
+	guint32 packet_ack  = tvb_get_ntohl(tvb, 0);
+	guint32 packet_seq;
+	//guint32 packet_type = tvb_get_ntohl(tvb, 10);
+	guint16 pdu_type = 0;
+	guint16 pdu_len = 0;
+	tvbuff_t *next_tvb;
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "HostARQ");
+	/* Clear out stuff in the info column */
+	col_clear(pinfo->cinfo,COL_INFO);
+	if (tvb_reported_length(tvb) <= 4)
+	//if (!packet_type)
+		col_add_fstr(pinfo->cinfo, COL_INFO, "ack %5u", packet_ack);
+	// ADD 4 < size < 12 => fail
+	else {
+		packet_seq = tvb_get_ntohl(tvb, 4);
+		pdu_type = tvb_get_ntohs(tvb, 8);
+		pdu_len  = tvb_get_ntohs(tvb, 10);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "ack %5u, seq %5u, type %14s, len %3u", /*, diff %u",*/
+			packet_ack,
+			packet_seq,
+			val_to_str(pdu_type, pdutypenames, "Unknown (0x%02x)"),
+			pdu_len/*,
+			(packet_ack > packet_seq) ? packet_ack - packet_seq : packet_seq - packet_ack // DEBUG
+			*/
+		);
+	}
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *hostarq_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_hostarq, tvb, 0, 12, ENC_BIG_ENDIAN); // just the hostarq header
+
+		hostarq_tree = proto_item_add_subtree(ti, ett_hostarq);
+		proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_ack, tvb, offset, 4, ENC_BIG_ENDIAN);
+		offset += 4;
+
+
+		// go to next dissector if valid data
+		if (tvb_reported_length_remaining(tvb, offset)) {
+			proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_seq, tvb, offset, 4, ENC_BIG_ENDIAN);
+			offset += 4;
+
+		//if (packet_type) {
+			next_tvb = tvb_new_subset(tvb, offset, -1, -1);
+
+			// sniff ahead :)
+			proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_type, tvb, offset, 2, ENC_BIG_ENDIAN);
+			offset += 2;
+			proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);
+			offset += 2;
+
+			dissector_try_uint(hostarq_dissector_table, pdu_type, next_tvb, pinfo, tree);
+		}
+	}
+}
+
+
+
+
+/* special RESET type frames */
+#define NMPM1FCPJTAG0_PORT 1700
+#define NMPM1FCPJTAG1_PORT 1701
+#define NMPM1FCPJTAG2_PORT 1702
+#define NMPM1FCPJTAG3_PORT 1703
+#define NMPM1FCPSYSSTART_PORT 1800
+#define NMPM1FCPRESET_PORT 1801
+#define NMPM1FCPHOSTARQRESET_PORT 45054
+
+static int proto_nmpm1fcp_special = -1;
+
+void
+proto_reg_handoff_nmpm1fcp_special(void)
+{
+	static dissector_handle_t nmpm1fcp_jtag_handle;
+	static dissector_handle_t nmpm1fcp_reset_handle;
+	static dissector_handle_t nmpm1fcp_sysstart_handle;
+	static dissector_handle_t nmpm1fcp_hostarqreset_handle;
+
+	nmpm1fcp_jtag_handle = create_dissector_handle(dissect_nmpm1fcp_jtag, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG0_PORT, nmpm1fcp_jtag_handle);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG1_PORT, nmpm1fcp_jtag_handle);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG2_PORT, nmpm1fcp_jtag_handle);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG3_PORT, nmpm1fcp_jtag_handle);
+
+	nmpm1fcp_reset_handle = create_dissector_handle(dissect_nmpm1fcp_reset, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPRESET_PORT, nmpm1fcp_reset_handle);
+
+	nmpm1fcp_sysstart_handle = create_dissector_handle(dissect_nmpm1fcp_sysstart, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPSYSSTART_PORT, nmpm1fcp_sysstart_handle);
+
+	nmpm1fcp_hostarqreset_handle = create_dissector_handle(dissect_nmpm1fcp_hostarqreset, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPHOSTARQRESET_PORT, nmpm1fcp_hostarqreset_handle);
+}
+
+
+static void
+dissect_nmpm1fcp_jtag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGAJTAG");
+	col_add_str(pinfo->cinfo, COL_INFO, "");
+	// nothing yet
+}
+
+static void
+dissect_nmpm1fcp_reset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	guint8 tmp;
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGARESET");
+
+	tmp = tvb_get_guint8(tvb, 0);
+	if (tmp == 0x55) {
+		tmp = tvb_get_guint8(tvb, 3);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "Reset: Core %u FPGADNC %u DDR2 %u DDR2SODIMM %u ARQ %u",
+			tmp>>0 & 0x1,
+			tmp>>1 & 0x1,
+			tmp>>2 & 0x1,
+			tmp>>3 & 0x1,
+			tmp>>4 & 0x1
+		);
+	} else
+		col_add_str(pinfo->cinfo, COL_INFO, "incorrect, wrong magic number");
+}
+
+static void
+dissect_nmpm1fcp_sysstart(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	guint8 tmp;
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGASYSSTART");
+
+	tmp = tvb_get_guint8(tvb, 0);
+	if (tmp == 0x55) {
+		tmp = tvb_get_guint8(tvb, 3);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "SysStart %s", tmp ? "on" : "off");
+	} else if (tmp == 0xc0 && tvb_get_guint8(tvb, 1) == 0x07) {
+		tmp = tvb_get_guint8(tvb, 3);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "SysStart Ack (deprecated): %s", tmp ? "on" : "off");
+	} else
+		col_add_str(pinfo->cinfo, COL_INFO, "incorrect, wrong magic number");
+}
+
+static void
+dissect_nmpm1fcp_hostarqreset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "HostARQ Reset");
+	col_add_str(pinfo->cinfo, COL_INFO, "");
+	/* other stuff was moved to HostARQ Cfg type */
+}
+
+
+
+
+
+
+
+/* payload starting here */
+
+static int proto_nmpm1fcp = -1;
+static gint ett_nmpm1fcp = -1;
+	
+#define FPGACONFIG_PTR       1<<(32-9)
+#define FPGACONFIG_FPL       1<<(32-8)
+#define FPGACONFIG_STC       1<<(32-7)
+#define FPGACONFIG_STP       1<<(32-6)
+#define FPGACONFIG_SOT       1<<(32-5)
+#define FPGACONFIG_STT       1<<(32-4)
+#define FPGACONFIG_STE       1<<(32-3)
+#define FPGACONFIG_CTM       1<<(32-2)
+#define FPGACONFIG_CPM       1<<(32-1)
+
+#define FPGATRACEDATA_FM     1<<(32-1)
+
+static int hf_nmpm1fcp_pdu_fpgaconfig_epl = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_str = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_stc = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_stp = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_sot = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_stt = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_ste = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_ctm = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_cpm = -1;
+		
+static int hf_nmpm1fcp_pdu_fpgaplayback_fpgatime = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_fpgacount = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_label = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_timestamp = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_hicanndata = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_hicanntag = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_hicanndest = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_overflow = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_trigger = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_dnc = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_hicann = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_tag = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_write = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_read = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_data = -1;
+
+static int hf_nmpm1fcp_pdu_fpgatracedata_timestamp = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_label = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_fm = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_overflow = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_flags = -1;
+
+
+
+
+void
+proto_register_nmpm1fcp(void)
+{
+	static hf_register_info hf[] = {
+		{ &hf_hostarq_pdu_type,
+			{ "NMPM1 FCP PDU Type", "nmpm1fcp.type",
+				FT_UINT16, BASE_HEX,
+				VALS(pdutypenames), 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_hostarq_pdu_len,
+			{ "NMPM1 FCP PDU Length", "nmpm1fcp.len",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+		/* FPGACONFIG */
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_str,
+			{ "FPGA Config Start Enable Systime Replace", "fpgaconfig.str",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_PTR,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_epl,
+			{ "FPGA Config Enable Loopback", "fpgaconfig.epl",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_FPL,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_stc,
+			{ "FPGA Config Start Read Traced Configuration", "fpgaconfig.stc",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STC,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_stp,
+			{ "FPGA Config Start Read Traced Pulses", "fpgaconfig.stp",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STP,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_sot,
+			{ "FPGA Config Stop Trace", "fpgaconfig.sot",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_SOT,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_stt,
+			{ "FPGA Config Start Trace", "fpgaconfig.stt",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STT,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_ste,
+			{ "FPGA Config Start Experiment", "fpgaconfig.ste",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STE,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_ctm,
+			{ "FPGA Config Clear Trace Memory", "fpgaconfig.ctm",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_CTM,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_cpm,
+			{ "FPGA Config Clear Playback Memory", "fpgaconfig.cpm",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_CPM,
+				NULL, HFILL }
+		},
+
+
+		/* FPGAPLAYBACK */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_fpgatime,
+			{ "FPGA Playback Data FPGA Time", "fpgaplayback.fpgatime",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_fpgacount,
+			{ "FPGA Playback Data Count", "fpgaplayback.fpgacount",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_label,
+			{ "FPGA Playback Data Label", "fpgaplayback.label",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_timestamp,
+			{ "FPGA Playback Data Timestamp", "fpgaplayback.timestamp",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		/* HICANN Configuration */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_hicanndata,
+			{ "FPGA Playback HICANN Data", "fpgaplayback.hicanndata",
+				FT_UINT64, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_hicanntag,
+			{ "FPGA Playback HICANN Tag", "fpgaplayback.hicanntag",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_hicanndest,
+			{ "FPGA Playback HICANN Dest", "fpgaplayback.hicanndest",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		/* Timestamp Overflow Indicator */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_overflow,
+			{ "FPGA Playback Overflow Indicator", "fpgaplayback.overflow",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		/* Timestamp Overflow Indicator */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_trigger,
+			{ "FPGA Playback Trigger", "fpgaplayback.trigger",
+				FT_UINT64, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+
+		/* HICANN CFG Data */
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_dnc,
+			{ "HICANN Configuration Data DNC", "hicanncfgdata.dnc",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_hicann,
+			{ "HICANN Configuration Data HICANN", "hicanncfgdata.hicann",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_tag,
+			{ "HICANN Configuration Data Tag", "hicanncfgdata.tag",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_write,
+			{ "HICANN Configuration Data Write", "hicanncfgdata.write",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_read,
+			{ "HICANN Configuration Data Read", "hicanncfgdata.read",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_data,
+			{ "HICANN Configuration Data", "hicanncfgdata.data",
+				FT_UINT64, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+
+		/* Trace Data */
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_timestamp,
+			{ "HICANN Trace Data Timestamp", "fpgatracedata.timestamp",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_label,
+			{ "HICANN Trace Data Label", "fpgatracedata.label",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_overflow,
+			{ "HICANN Trace Data Overflow", "fpgatracedata.overflow",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_fm,
+			{ "HICANN Trace Data Flags", "fpgatracedata.fm",
+				FT_BOOLEAN, 1,
+				NULL, FPGATRACEDATA_FM,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_flags,
+			{ "HICANN Trace Data Flags", "fpgatracedata.flags",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+	};
+
+	/* Setup protocol subtree array */
+	static gint *ett[] = {
+		&ett_nmpm1fcp
+	};
+
+	proto_nmpm1fcp = proto_register_protocol (
+		"HBP NMPM1 FCP Protocol", /* name       */
+		"NMPM1 FCP",              /* short name */
+		"nmpm1fcp"                /* abbrev     */
+	);
+
+	proto_register_field_array(proto_nmpm1fcp, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+	hostarq_dissector_table = register_dissector_table("nmpm1fcp.type",
+	                                                   "NMPM1 FCP PDU Type",
+	                                                   FT_UINT16, BASE_HEX);
+}
+
+void
+proto_reg_handoff_nmpm1fcp(void)
+{
+	static dissector_handle_t nmpm1fcp_hostarqcfg_handle;
+	static dissector_handle_t nmpm1fcp_fpgaconfig_handle;
+	static dissector_handle_t nmpm1fcp_fpgaplayback_handle;
+	static dissector_handle_t nmpm1fcp_hicanncfgdata_handle;
+	static dissector_handle_t nmpm1fcp_fpgatracedata_handle;
+
+	nmpm1fcp_hostarqcfg_handle = create_dissector_handle(dissect_nmpm1fcp_hostarqcfg, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", HOSTARQ_CFG, nmpm1fcp_hostarqcfg_handle);
+
+	nmpm1fcp_fpgaconfig_handle = create_dissector_handle(dissect_nmpm1fcp_fpgaconfig, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", FPGACONFIG, nmpm1fcp_fpgaconfig_handle);
+
+	nmpm1fcp_fpgaplayback_handle = create_dissector_handle(dissect_nmpm1fcp_fpgaplayback, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", FPGAPLAYBACK, nmpm1fcp_fpgaplayback_handle);
+
+	nmpm1fcp_hicanncfgdata_handle = create_dissector_handle(dissect_nmpm1fcp_hicanncfgdata, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", HICANNCONFIG, nmpm1fcp_hicanncfgdata_handle);
+	
+	nmpm1fcp_fpgatracedata_handle = create_dissector_handle(dissect_nmpm1fcp_fpgatracedata, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", FPGATRACE, nmpm1fcp_fpgatracedata_handle);
+	// add other dissector foos here
+}
+
+static void
+dissect_nmpm1fcp_hostarqcfg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	guint64 max_nrframes = 0, max_winsiz = 0, max_pduwords = 0;
+	guint offset = 4; // skip typelen
+
+	max_nrframes = tvb_get_ntoh64(tvb, offset);
+	offset += 8;
+	max_winsiz = tvb_get_ntoh64(tvb, offset);
+	offset += 8;
+	max_pduwords = tvb_get_ntoh64(tvb, offset);
+	offset += 8;
+
+	col_set_str(pinfo->cinfo, COL_INFO, "HostARQ Config");
+	col_append_fstr(pinfo->cinfo, COL_INFO,
+					": MAX_NRFRAMES %llu MAX_WINSIZ %llu MAX_PDUWORDS %llu",
+					(long long unsigned) max_nrframes,
+					(long long unsigned) max_winsiz,
+					(long long unsigned) max_pduwords);
+}
+
+
+static void
+dissect_nmpm1fcp_fpgaconfig(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	gint offset = 0;
+	guint32 tmp = 0;
+	
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGACONFIG");
+
+	tmp  = tvb_get_ntohl(tvb, 8); // skip type-len
+	if (tmp) {
+		col_append_str(pinfo->cinfo, COL_INFO, ", ");
+		if (tmp & FPGACONFIG_PTR) col_append_str(pinfo->cinfo, COL_INFO, "PTR ");
+		if (tmp & FPGACONFIG_FPL) col_append_str(pinfo->cinfo, COL_INFO, "FPL ");
+		if (tmp & FPGACONFIG_STC) col_append_str(pinfo->cinfo, COL_INFO, "STC ");
+		if (tmp & FPGACONFIG_STP) col_append_str(pinfo->cinfo, COL_INFO, "STP ");
+		if (tmp & FPGACONFIG_SOT) col_append_str(pinfo->cinfo, COL_INFO, "SOT ");
+		if (tmp & FPGACONFIG_STT) col_append_str(pinfo->cinfo, COL_INFO, "STT ");
+		if (tmp & FPGACONFIG_STE) col_append_str(pinfo->cinfo, COL_INFO, "STE ");
+		if (tmp & FPGACONFIG_CTM) col_append_str(pinfo->cinfo, COL_INFO, "CTM ");
+		if (tmp & FPGACONFIG_CPM) col_append_str(pinfo->cinfo, COL_INFO, "CPM ");
+	}
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *fpgaconfig_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		fpgaconfig_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+		
+		offset += 4; // TYPLEN
+		offset += 4; // upper bits of config frame are unused
+
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_str, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_epl, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_stc, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_stp, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_sot, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_stt, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_ste, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_ctm, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_cpm, tvb, offset, 4, ENC_BIG_ENDIAN);
+		// skip second 32-bit entry: it's empty!
+		offset += 8; // end of 8-byte payload entry
+	}
+}
+
+static void
+dissect_nmpm1fcp_fpgaplayback(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	gint offset = 0;
+	gboolean is_data = 0;
+	gboolean is_pulse = 0;
+	gboolean is_overflow = 0;
+	guint32 tmp = 0;
+	guint64 tmp64 = 0;
+	//guint16 type = tvb_get_ntohs(tvb, 0);
+	guint16 len = tvb_get_ntohs(tvb, 2);
+	size_t i = 0, ii = 0;
+	guint16 group_len = 0;
+	
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGAPLAYBACK");
+
+	//pbtype = tvb_get_ntohs(tvb, 4);
+	//if ( ((pbtype & 0x1) == 0) && ((pbtype & (1<<15)) == 0) ) {
+	//	/* Pulse entry */
+	//	tmp = (pbtype & 0x7fff) >> 1; // get lower 15 bits and shift right once
+	//	col_append_fstr(pinfo->cinfo, COL_INFO, " FPGA Time %u", tmp);
+	//	tmp = (tvb_get_ntohs(tvb, 6) & 0x3fff); // lower 14 bits
+	//	col_append_fstr(pinfo->cinfo, COL_INFO, " Count %u", tmp);
+	//}
+	offset += 4;
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *fpgaplayback_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		fpgaplayback_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+
+		// we should check for nodata here!
+
+		for (i = 0; i < len; i++) {
+
+			group_len = (tvb_get_ntohs(tvb, offset+4) >> 2) & 0x3fff;
+			is_data = !((tvb_get_ntohs(tvb, offset+6)) & 0x1);
+			is_pulse = !((tvb_get_ntohs(tvb, offset+4)) & 0x1);
+			is_overflow = !((tvb_get_ntohs(tvb, offset+6)) & 0x2) >> 1;
+
+			if (is_data && is_pulse) {
+				/* Pulse group */
+				i += group_len / 2; // 1 => +0, 2 => +1, 3 => +1, 4 => +2, ...
+
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_label,     tvb, offset* 8+2, 12, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_timestamp, tvb, offset* 8, 15, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgacount, tvb, offset* 8, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgatime,  tvb, offset* 8+1, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+
+				for (ii = 1; ii < group_len; ii++) {
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_label,     tvb, offset* 8+2, 12, ENC_BIG_ENDIAN);
+					offset += 2;
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_timestamp, tvb, offset* 8, 15, ENC_BIG_ENDIAN);
+					offset += 2;
+				}
+				if ((group_len % 2) == 0) // if even, skip 2 bytes padding
+					offset += 2;
+					
+			} else if (is_data && !is_pulse) {
+				/* HICANN configuration */
+				i += group_len;
+
+				offset += 2;
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgacount, tvb, offset* 8, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgatime,  tvb, offset* 8+1, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+
+				for (ii = 0; ii < group_len; ii++) {
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanndest, tvb, offset*8, 5, ENC_BIG_ENDIAN);
+					offset += 1; // 1 byte
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanntag, tvb, offset*8+6, 1, ENC_BIG_ENDIAN);
+					// 7 more bits
+					tmp64    = tvb_get_ntoh64(tvb, offset) & 0xFFFffffFFFFffff; // remaining 49 bits
+					proto_tree_add_uint64_format(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanndata, tvb, offset, 8, tmp64, "HICANN Data: 0x%llx", (long long unsigned)tmp64);
+					//proto_tree_add_uint64(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanndata, tvb, offset, 8, tmp64);
+					offset += 7;
+				}
+			} else if (!is_data && is_overflow) {
+				i += 1;
+				/* Timestamp Overflow Indicator */
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_overflow, tvb, offset*8, 30, ENC_BIG_ENDIAN);
+				offset += 8;
+			} else if (!is_data && !is_overflow) {
+				i += 1;
+				/* Wait for next experiment trigger */
+				proto_tree_add_string(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_trigger, tvb, offset*8+2, 64, "Wait for next experiment");
+				offset += 8;
+			} else {
+				// WTF
+			}
+		}
+	}
+}
+
+static void
+dissect_nmpm1fcp_hicanncfgdata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	//guint16 type = tvb_get_ntohs(tvb, 0);
+	guint16 len = tvb_get_ntohs(tvb, 2);
+	gint offset = 4;
+	size_t ii = 0;
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "HICANNCONFIG");
+
+	//col_append_fstr(pinfo->cinfo, COL_INFO, " DNC %u HICANN %u", (unsigned)dnc, (unsigned)hicann);
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *hicanncfgdata_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		hicanncfgdata_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+	
+		for (ii = 0; ii < len; ii++) { 
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_dnc, tvb, offset*8, 2, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_hicann, tvb, offset*8+2, 3, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_tag,  tvb, offset*8+2+3+9, 1, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_write,  tvb, offset*8+2+3+9+1, 1, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_read,  tvb, (offset+4)*8, 1, ENC_BIG_ENDIAN);
+			//proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_data, tvb, offset*8, 49, ENC_BIG_ENDIAN);
+			offset += 8;
+		}
+	}
+}
+
+static void
+dissect_nmpm1fcp_fpgatracedata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	//guint16 type = tvb_get_ntohs(tvb, 0);
+	guint16 len = tvb_get_ntohs(tvb, 2);
+	gint offset = 4;
+	guint8 tmp = 0;
+	size_t ii = 0;
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGATRACE");
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *fpgatracedata_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		fpgatracedata_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+	
+		for (ii = 0; ii < len*2; ii++) { // dword-wise!
+			proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_flags, tvb, offset*8, 2, ENC_BIG_ENDIAN);
+			tmp = tvb_get_guint8(tvb, offset) & 0x3;
+			switch (tmp) {
+				case 0:
+					proto_tree_add_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_fm, tvb, offset, 4, ENC_BIG_ENDIAN);
+					proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_label,     tvb, offset*8+5, 12, ENC_BIG_ENDIAN);
+					offset += 2;
+					proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_timestamp, tvb, offset*8+1, 15, ENC_BIG_ENDIAN);
+					offset += 2;
+					break;
+				case 1:
+					// just padding...
+					proto_tree_add_text(fpgatracedata_tree, tvb, offset, 4, "padding");
+					offset += 4;
+					break;
+				case 2:
+				case 3:
+					//overflow because higher bit high
+					proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_overflow, tvb, offset*8+1, 31, ENC_BIG_ENDIAN);
+					offset += 4;
+					break;
+				default:
+					break;
+			}
+		}
+	}
+}
+
+#undef HOSTARQ_PORT
+#undef JTAGBULK
+#undef JTAGSINGLE
+#undef I2C
+#undef FPGATRACE
+#undef HICANNREAD
+#undef FPGAPLAYBACK
+#undef FPGAROUTING
+#undef FPGACONFIG
+#undef FPGABWLIMIT
+#undef DNCROUTING
+#undef DNCCONFIG
+#undef HICANNCONFIG
diff --git a/hmf-wireshark/packet-hostarq.h b/hmf-wireshark/packet-hostarq.h
new file mode 100644
index 0000000000..29a56fbc58
--- /dev/null
+++ b/hmf-wireshark/packet-hostarq.h
@@ -0,0 +1,12 @@
+static void dissect_hostarq(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+static void dissect_nmpm1fcp_jtag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_reset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_sysstart(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_hostarqreset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+static void dissect_nmpm1fcp_hostarqcfg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_fpgaconfig(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_fpgaplayback(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_hicanncfgdata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_fpgatracedata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
diff --git a/hmf-wireshark/plugin.rc.in b/hmf-wireshark/plugin.rc.in
new file mode 100644
index 0000000000..568dc07b49
--- /dev/null
+++ b/hmf-wireshark/plugin.rc.in
@@ -0,0 +1,34 @@
+#include "winver.h"
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION @RC_MODULE_VERSION@
+ PRODUCTVERSION @RC_VERSION@
+ FILEFLAGSMASK 0x0L
+#ifdef _DEBUG
+ FILEFLAGS VS_FF_DEBUG
+#else
+ FILEFLAGS 0
+#endif
+ FILEOS VOS_NT_WINDOWS32
+ FILETYPE VFT_DLL
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "CompanyName", "The Wireshark developer community, http://www.wireshark.org/\0"
+            VALUE "FileDescription", "@PACKAGE@ dissector\0"
+            VALUE "FileVersion", "@MODULE_VERSION@\0"
+            VALUE "InternalName", "@PACKAGE@ @MODULE_VERSION@\0"
+            VALUE "LegalCopyright", "Copyright  1998 Gerald Combs <gerald@wireshark.org>, Gilbert Ramirez <gram@alumni.rice.edu> and others\0"
+            VALUE "OriginalFilename", "@PLUGIN_NAME@.dll\0"
+            VALUE "ProductName", "Wireshark\0"
+            VALUE "ProductVersion", "@VERSION@\0"
+            VALUE "Comments", "Build with @MSVC_VARIANT@\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
diff --git a/plugins/Makefile.am b/plugins/Makefile.am
index 2055eb1b0e..8ecd5ab783 100644
--- a/plugins/Makefile.am
+++ b/plugins/Makefile.am
@@ -25,6 +25,7 @@ SUBDIRS = \
 	$(_CUSTOM_SUBDIRS_) \
 	epan/ethercat		\
 	epan/gryphon		\
+	epan/hostarq		\
 	epan/irda		\
 	epan/mate		\
 	epan/opcua		\
diff --git a/plugins/epan/hostarq/.gitignore b/plugins/epan/hostarq/.gitignore
new file mode 100644
index 0000000000..c7478fe7d1
--- /dev/null
+++ b/plugins/epan/hostarq/.gitignore
@@ -0,0 +1,5 @@
+.deps/
+.libs/
+*.la
+*.lo
+*.o
diff --git a/plugins/epan/hostarq/.packet-hostarq.h.swo b/plugins/epan/hostarq/.packet-hostarq.h.swo
new file mode 100644
index 0000000000..b40cfbd2dd
Binary files /dev/null and b/plugins/epan/hostarq/.packet-hostarq.h.swo differ
diff --git a/plugins/epan/hostarq/AUTHORS b/plugins/epan/hostarq/AUTHORS
new file mode 100644
index 0000000000..bc80bf18d6
--- /dev/null
+++ b/plugins/epan/hostarq/AUTHORS
@@ -0,0 +1,2 @@
+Author :
+Eric Müller <mueller@kip.uni-heidelberg.de>
diff --git a/plugins/epan/hostarq/CMakeLists.txt b/plugins/epan/hostarq/CMakeLists.txt
new file mode 100644
index 0000000000..64d6d29515
--- /dev/null
+++ b/plugins/epan/hostarq/CMakeLists.txt
@@ -0,0 +1,65 @@
+# CMakeLists.txt
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+
+include(WiresharkPlugin)
+
+# Plugin name and version info (major minor micro extra)
+set_module_info(hostarq 0 0 1 0)
+
+set(DISSECTOR_SRC
+	packet-hostarq.c
+)
+
+set(PLUGIN_FILES
+	plugin.c
+	${DISSECTOR_SRC}
+)
+
+set_source_files_properties(
+	${PLUGIN_FILES}
+	PROPERTIES
+	COMPILE_FLAGS "${WERROR_COMMON_FLAGS}"
+)
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+
+register_plugin_files(plugin.c
+	plugin
+	${DISSECTOR_SRC}
+)
+
+add_plugin_library(hostarq epan)
+
+target_link_libraries(hostarq epan)
+
+install_plugin(hostarq epan)
+
+file(GLOB DISSECTOR_HEADERS RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "*.h")
+CHECKAPI(
+	NAME
+	  hostarq
+	SWITCHES
+	  -g abort -g termoutput -build
+	SOURCES
+	  ${DISSECTOR_SRC}
+	  ${DISSECTOR_HEADERS}
+)
+
+#
+# Editor modelines  -  http://www.wireshark.org/tools/modelines.html
+#
+# Local variables:
+# c-basic-offset: 8
+# tab-width: 8
+# indent-tabs-mode: t
+# End:
+#
+# vi: set shiftwidth=8 tabstop=8 noexpandtab:
+# :indentSize=8:tabSize=8:noTabs=false:
+#
diff --git a/plugins/epan/hostarq/COPYING b/plugins/epan/hostarq/COPYING
new file mode 100644
index 0000000000..d60c31a97a
--- /dev/null
+++ b/plugins/epan/hostarq/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/plugins/epan/hostarq/ChangeLog b/plugins/epan/hostarq/ChangeLog
new file mode 100644
index 0000000000..0986b7c6ee
--- /dev/null
+++ b/plugins/epan/hostarq/ChangeLog
@@ -0,0 +1,2 @@
+Initial Implementation
+2014-06-20
diff --git a/plugins/epan/hostarq/Makefile.am b/plugins/epan/hostarq/Makefile.am
new file mode 100644
index 0000000000..c6ee221d68
--- /dev/null
+++ b/plugins/epan/hostarq/Makefile.am
@@ -0,0 +1,66 @@
+# Makefile.am
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+include $(top_srcdir)/Makefile.am.inc
+include $(top_srcdir)/plugins/epan/Makefile.am.inc
+
+# the name of the plugin
+PLUGIN_NAME = hostarq
+
+PLUGIN_VERSION = 1.1.0
+
+BUILT_SOURCES = \
+	plugin.c
+
+# Non-generated sources to be scanned for registration routines
+NONGENERATED_REGISTER_C_FILES = \
+	packet-hostarq.c
+
+# Non-generated sources
+NONGENERATED_C_FILES = \
+	$(NONGENERATED_REGISTER_C_FILES)
+
+# Headers.
+CLEAN_HEADER_FILES = \
+	packet-hostarq.h
+
+HEADER_FILES = \
+	$(CLEAN_HEADER_FILES)
+
+epan_plugin_LTLIBRARIES = hostarq.la
+
+hostarq_la_SOURCES = \
+	$(SRC_FILES)	\
+	$(HEADER_FILES)
+
+nodist_hostarq_la_SOURCES = \
+	plugin.c
+
+hostarq_la_CPPFLAGS = $(AM_CPPFLAGS) $(PLUGIN_CPPFLAGS)
+
+hostarq_la_CFLAGS = $(AM_CFLAGS) $(PLUGIN_CFLAGS)
+
+hostarq_la_LDFLAGS = $(PLUGIN_LDFLAGS)
+
+DISTCLEANFILES = \
+	plugin.c
+
+EXTRA_DIST = \
+	CMakeLists.txt
diff --git a/plugins/epan/hostarq/Makefile.common b/plugins/epan/hostarq/Makefile.common
new file mode 100644
index 0000000000..d56bb43d7e
--- /dev/null
+++ b/plugins/epan/hostarq/Makefile.common
@@ -0,0 +1,38 @@
+# Makefile.common for HostARQ & NMPM1 FCP plugin
+#     Contains the stuff from Makefile.am and Makefile.nmake that is
+#     a) common to both files and
+#     b) portable between both files
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+# the name of the plugin
+PLUGIN_NAME = hostarq
+
+# the dissector sources (without any helpers)
+DISSECTOR_SRC = \
+	packet-hostarq.c
+
+# corresponding headers
+DISSECTOR_INCLUDES =	\
+	packet-hostarq.h
+
+# Dissector helpers. They're included in the source files in this
+# directory, but they're not dissectors themselves, i.e. they're not
+# used to generate "plugin.c".
+DISSECTOR_SUPPORT_SRC =
diff --git a/plugins/epan/hostarq/Makefile.nmake b/plugins/epan/hostarq/Makefile.nmake
new file mode 100644
index 0000000000..deacd63862
--- /dev/null
+++ b/plugins/epan/hostarq/Makefile.nmake
@@ -0,0 +1,104 @@
+# Makefile.nmake
+# nmake file for Wireshark plugin
+#
+# $Id: Makefile.nmake 42971 2012-06-01 14:08:12Z wmeier $
+#
+
+include ..\..\config.nmake
+include moduleinfo.nmake
+
+include Makefile.common
+
+CFLAGS=$(WARNINGS_ARE_ERRORS) $(STANDARD_CFLAGS) \
+	/I../.. $(GLIB_CFLAGS) \
+	/I$(PCAP_DIR)\include
+
+.c.obj::
+	$(CC) $(CFLAGS) -Fd.\ -c $<
+
+LDFLAGS = $(PLUGIN_LDFLAGS)
+
+!IFDEF ENABLE_LIBWIRESHARK
+LINK_PLUGIN_WITH=..\..\epan\libwireshark.lib
+CFLAGS=/D_NEED_VAR_IMPORT_ $(CFLAGS)
+
+DISSECTOR_OBJECTS = $(DISSECTOR_SRC:.c=.obj)
+
+DISSECTOR_SUPPORT_OBJECTS = $(DISSECTOR_SUPPORT_SRC:.c=.obj)
+
+OBJECTS = $(DISSECTOR_OBJECTS) $(DISSECTOR_SUPPORT_OBJECTS) plugin.obj
+
+RESOURCE=$(PLUGIN_NAME).res
+
+all: $(PLUGIN_NAME).dll
+
+$(PLUGIN_NAME).rc : moduleinfo.nmake
+	sed -e s/@PLUGIN_NAME@/$(PLUGIN_NAME)/ \
+	-e s/@RC_MODULE_VERSION@/$(RC_MODULE_VERSION)/ \
+	-e s/@RC_VERSION@/$(RC_VERSION)/ \
+	-e s/@MODULE_VERSION@/$(MODULE_VERSION)/ \
+	-e s/@PACKAGE@/$(PACKAGE)/ \
+	-e s/@VERSION@/$(VERSION)/ \
+	-e s/@MSVC_VARIANT@/$(MSVC_VARIANT)/ \
+	< plugin.rc.in > $@
+
+$(PLUGIN_NAME).dll $(PLUGIN_NAME).exp $(PLUGIN_NAME).lib : $(OBJECTS) $(LINK_PLUGIN_WITH) $(RESOURCE)
+	link -dll /out:$(PLUGIN_NAME).dll $(LDFLAGS) $(OBJECTS) $(LINK_PLUGIN_WITH) \
+	$(GLIB_LIBS) $(RESOURCE)
+
+#
+# Build plugin.c, which contains the plugin version[] string, a
+# function plugin_register() that calls the register routines for all
+# protocols, and a function plugin_reg_handoff() that calls the handoff
+# registration routines for all protocols.
+#
+# We do this by scanning sources.  If that turns out to be too slow,
+# maybe we could just require every .o file to have an register routine
+# of a given name (packet-aarp.o -> proto_register_aarp, etc.).
+#
+# Formatting conventions:  The name of the proto_register_* routines an
+# proto_reg_handoff_* routines must start in column zero, or must be
+# preceded only by "void " starting in column zero, and must not be
+# inside #if.
+#
+# DISSECTOR_SRC is assumed to have all the files that need to be scanned.
+#
+# For some unknown reason, having a big "for" loop in the Makefile
+# to scan all the files doesn't work with some "make"s; they seem to
+# pass only the first few names in the list to the shell, for some
+# reason.
+#
+# Therefore, we have a script to generate the plugin.c file.
+# The shell script runs slowly, as multiple greps and seds are run
+# for each input file; this is especially slow on Windows.  Therefore,
+# if Python is present (as indicated by PYTHON being defined), we run
+# a faster Python script to do that work instead.
+#
+# The first argument is the directory in which the source files live.
+# The second argument is "plugin", to indicate that we should build
+# a plugin.c file for a plugin.
+# All subsequent arguments are the files to scan.
+#
+!IFDEF PYTHON
+plugin.c: $(DISSECTOR_SRC) moduleinfo.h Makefile.common ../../tools/make-dissector-reg.py
+	@echo Making plugin.c (using python)
+	@$(PYTHON) "../../tools/make-dissector-reg.py" . plugin $(DISSECTOR_SRC)
+!ELSE
+plugin.c: $(DISSECTOR_SRC) moduleinfo.h Makefile.common ../../tools/make-dissector-reg
+	@echo Making plugin.c (using sh)
+	@$(SH) ../../tools/make-dissector-reg . plugin $(DISSECTOR_SRC)
+!ENDIF
+
+!ENDIF
+
+clean:
+	rm -f $(OBJECTS) $(RESOURCE) plugin.c *.pdb *.sbr \
+	    $(PLUGIN_NAME).dll $(PLUGIN_NAME).dll.manifest $(PLUGIN_NAME).lib \
+	    $(PLUGIN_NAME).exp $(PLUGIN_NAME).rc
+
+distclean: clean
+
+maintainer-clean: distclean
+
+checkapi:
+	$(PERL) ../../tools/checkAPIs.pl -g abort -g termoutput -build $(DISSECTOR_SRC) $(DISSECTOR_INCLUDES)
diff --git a/plugins/epan/hostarq/README.md b/plugins/epan/hostarq/README.md
new file mode 100644
index 0000000000..58bd584490
--- /dev/null
+++ b/plugins/epan/hostarq/README.md
@@ -0,0 +1,24 @@
+Wireshark Dissector for NMPM FCP Communication
+==============================================
+
+A Wireshark Plugin for Dissection of HBP/NMPM Communication.
+
+Tested on Debian wheezy's wireshark 1.8.2.
+
+
+Building
+--------
+    $ apt-get source wireshark/wheezy
+    $ cd wireshark-1.8.2/plugins
+    $ git clone https://github.com/muffgaga/wireshark-dissector-nmpmfcp.git hostarq
+    # add "hostarq" to @SUBDIRS@ variable in plugins/Makefile.am
+    # add "plugins/hostarq/Makefile" to "AC_OUTPUT" in configure.ac
+    $ ./autogen.sh
+    $ ./configure
+    $ make
+
+
+Edit-Test Cycle
+---------------
+    $ make -C plugins
+    $ WIRESHARK_RUN_FROM_BUILD_DIRECTORY=1 ./wireshark
diff --git a/plugins/epan/hostarq/moduleinfo.h b/plugins/epan/hostarq/moduleinfo.h
new file mode 100644
index 0000000000..987dfce522
--- /dev/null
+++ b/plugins/epan/hostarq/moduleinfo.h
@@ -0,0 +1,16 @@
+/* Included *after* config.h, in order to re-define these macros */
+
+#ifdef PACKAGE
+#undef PACKAGE
+#endif
+
+/* Name of package */
+#define PACKAGE "hostarq"
+
+
+#ifdef VERSION
+#undef VERSION
+#endif
+
+/* Version number of package */
+#define VERSION "0.0.1"
diff --git a/plugins/epan/hostarq/moduleinfo.nmake b/plugins/epan/hostarq/moduleinfo.nmake
new file mode 100644
index 0000000000..378e15ca3b
--- /dev/null
+++ b/plugins/epan/hostarq/moduleinfo.nmake
@@ -0,0 +1,27 @@
+#
+#
+
+# The name
+PACKAGE=hostarq
+
+# The version
+MODULE_VERSION_MAJOR=0
+MODULE_VERSION_MINOR=0
+MODULE_VERSION_MICRO=1
+MODULE_VERSION_EXTRA=0
+
+#
+# The RC_VERSION should be comma-separated, not dot-separated, 
+# as per Graham Bloice's message in
+#
+#	http://www.ethereal.com/lists/ethereal-dev/200303/msg00283.html
+#
+# "The RC_VERSION variable in config.nmake should be comma separated. 
+# This allows the resources to be built correctly and the version
+# number to be correctly displayed in the explorer properties dialog
+# for the executables, and XP's tooltip, rather than 0.0.0.0."
+#
+
+MODULE_VERSION=$(MODULE_VERSION_MAJOR).$(MODULE_VERSION_MINOR).$(MODULE_VERSION_MICRO).$(MODULE_VERSION_EXTRA)
+RC_MODULE_VERSION=$(MODULE_VERSION_MAJOR),$(MODULE_VERSION_MINOR),$(MODULE_VERSION_MICRO),$(MODULE_VERSION_EXTRA)
+
diff --git a/plugins/epan/hostarq/packet-hostarq.c b/plugins/epan/hostarq/packet-hostarq.c
new file mode 100644
index 0000000000..33bdb0b91f
--- /dev/null
+++ b/plugins/epan/hostarq/packet-hostarq.c
@@ -0,0 +1,853 @@
+/* packet-hostarq.c
+ *
+ * Routines for HostARQ protocol packet disassembly
+ * by the Electronic Visons group of the
+ * Kirchhoff-Institute for Physics, Heidelberg University
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include "config.h"
+
+//#include <glib.h>
+#include <epan/packet.h>
+#include <epan/dissectors/packet-udp.h>
+#include <epan/prefs.h>
+#include "packet-hostarq.h"
+
+#define HOSTARQ_PORT 1234
+
+#define HOSTARQ_LOOP 0x8001
+#define HOSTARQ_CFG  0x8002
+
+#define JTAGBULK     0x0C33
+#define JTAGSINGLE   0x0C3A
+#define I2C          0x0CCC
+#define FPGATRACE    0x0CA5
+#define HICANNREAD   0x0CA3
+#define FPGAPLAYBACK 0x0C5A
+#define FPGAROUTING  0x0CAA
+#define FPGACONFIG   0x0C1B
+#define FPGABWLIMIT  0x0DB0
+#define DNCROUTING   0x1364
+#define DNCCONFIG    0x1361
+#define HICANNCONFIG 0x2A1B
+
+static const value_string pdutypenames[] = {
+	// copied from host_al_controller.h
+	{ JTAGBULK,     "JTAGBULK" },
+	{ JTAGSINGLE,   "JTAGSINGLE" },
+	{ HOSTARQ_CFG,  "HOSTARQ_CFG" },
+	{ HOSTARQ_LOOP, "HOSTARQ_LOOP" },
+	{ I2C,          "I2C" },
+	{ FPGATRACE,    "FPGATRACE" },
+	{ HICANNREAD,   "HICANNREAD" },
+	{ FPGAPLAYBACK, "FPGAPLAYBACK" },
+	{ FPGAROUTING,  "FPGAROUTING" },
+	{ FPGACONFIG,   "FPGACONFIG" },
+	{ FPGABWLIMIT,  "FPGABWLIMIT" },
+	{ DNCROUTING,   "DNCROUTING" },
+	{ DNCCONFIG,    "DNCCONFIG" },
+	{ HICANNCONFIG, "HICANNCONFIG" },
+	{ 0, NULL}
+};
+
+static int proto_hostarq = -1;
+
+static int hf_hostarq_pdu_ack = -1;
+static int hf_hostarq_pdu_seq = -1;
+static int hf_hostarq_pdu_valid = -1;
+static int hf_hostarq_pdu_type = -1;
+static int hf_hostarq_pdu_len = -1;
+
+static gint ett_hostarq = -1;
+
+static dissector_table_t hostarq_dissector_table = NULL;
+
+static const value_string packettypenames[] = {
+	{ 0,          "ACK"  },
+	{ 1,          "DATA" },
+	{ 0xffffffff, "DATA" }
+};
+
+void
+proto_register_hostarq(void)
+{
+	static hf_register_info hf[] = {
+		{ &hf_hostarq_pdu_ack,
+			{ "HostARQ PDU Acknowledge", "hostarq.ack",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_hostarq_pdu_seq,
+			{ "HostARQ PDU Sequence", "hostarq.seq",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		}/*,
+		{ &hf_hostarq_pdu_valid,
+			{ "HostARQ PDU Valid", "hostarq.valid",
+				FT_UINT32, BASE_HEX,
+				VALS(packettypenames), 0x0,
+				NULL, HFILL }
+		} */
+	};
+
+	/* Setup protocol subtree array */
+	static gint *ett[] = {
+		&ett_hostarq
+	};
+
+	proto_hostarq = proto_register_protocol (
+		"HostARQ Protocol", /* name       */
+		"HostARQ",          /* short name */
+		"hostarq"           /* abbrev     */
+	);
+
+	proto_register_field_array(proto_hostarq, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+}
+
+void
+proto_reg_handoff_hostarq(void)
+{
+	dissector_handle_t hostarq_handle;
+
+	hostarq_handle = create_dissector_handle(dissect_hostarq, proto_hostarq);
+	dissector_add_uint("udp.port", HOSTARQ_PORT, hostarq_handle);
+}
+
+static int
+dissect_hostarq(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+	gint offset = 0;
+	guint32 packet_ack  = tvb_get_ntohl(tvb, 0);
+	guint32 packet_seq;
+	//guint32 packet_type = tvb_get_ntohl(tvb, 10);
+	guint16 pdu_type = 0;
+	guint16 pdu_len = 0;
+	tvbuff_t *next_tvb;
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "HostARQ");
+	/* Clear out stuff in the info column */
+	col_clear(pinfo->cinfo,COL_INFO);
+	if (tvb_reported_length(tvb) <= 4)
+	//if (!packet_type)
+		col_add_fstr(pinfo->cinfo, COL_INFO, "ack %5u", packet_ack);
+	// ADD 4 < size < 12 => fail
+	else {
+		packet_seq = tvb_get_ntohl(tvb, 4);
+		pdu_type = tvb_get_ntohs(tvb, 8);
+		pdu_len  = tvb_get_ntohs(tvb, 10);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "ack %5u, seq %5u, type %14s, len %3u", /*, diff %u",*/
+			packet_ack,
+			packet_seq,
+			val_to_str(pdu_type, pdutypenames, "Unknown (0x%02x)"),
+			pdu_len/*,
+			(packet_ack > packet_seq) ? packet_ack - packet_seq : packet_seq - packet_ack // DEBUG
+			*/
+		);
+	}
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *hostarq_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_hostarq, tvb, 0, 12, ENC_BIG_ENDIAN); // just the hostarq header
+
+		hostarq_tree = proto_item_add_subtree(ti, ett_hostarq);
+		proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_ack, tvb, offset, 4, ENC_BIG_ENDIAN);
+		offset += 4;
+
+
+		// go to next dissector if valid data
+		if (tvb_reported_length_remaining(tvb, offset)) {
+			proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_seq, tvb, offset, 4, ENC_BIG_ENDIAN);
+			offset += 4;
+
+		//if (packet_type) {
+			next_tvb = tvb_new_subset_length_caplen(tvb, offset, -1, -1);
+
+			// sniff ahead :)
+			proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_type, tvb, offset, 2, ENC_BIG_ENDIAN);
+			offset += 2;
+			proto_tree_add_item(hostarq_tree, hf_hostarq_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);
+			offset += 2;
+
+			dissector_try_uint(hostarq_dissector_table, pdu_type, next_tvb, pinfo, tree);
+		}
+	}
+	return 1;
+}
+
+
+
+
+/* special RESET type frames */
+#define NMPM1FCPJTAG0_PORT 1700
+#define NMPM1FCPJTAG1_PORT 1701
+#define NMPM1FCPJTAG2_PORT 1702
+#define NMPM1FCPJTAG3_PORT 1703
+#define NMPM1FCPSYSSTART_PORT 1800
+#define NMPM1FCPRESET_PORT 1801
+#define NMPM1FCPHOSTARQRESET_PORT 45054
+
+static int proto_nmpm1fcp_special = -1;
+
+void
+proto_reg_handoff_nmpm1fcp_special(void)
+{
+	static dissector_handle_t nmpm1fcp_jtag_handle;
+	static dissector_handle_t nmpm1fcp_reset_handle;
+	static dissector_handle_t nmpm1fcp_sysstart_handle;
+	static dissector_handle_t nmpm1fcp_hostarqreset_handle;
+
+	nmpm1fcp_jtag_handle = create_dissector_handle(dissect_nmpm1fcp_jtag, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG0_PORT, nmpm1fcp_jtag_handle);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG1_PORT, nmpm1fcp_jtag_handle);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG2_PORT, nmpm1fcp_jtag_handle);
+	dissector_add_uint("udp.port", NMPM1FCPJTAG3_PORT, nmpm1fcp_jtag_handle);
+
+	nmpm1fcp_reset_handle = create_dissector_handle(dissect_nmpm1fcp_reset, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPRESET_PORT, nmpm1fcp_reset_handle);
+
+	nmpm1fcp_sysstart_handle = create_dissector_handle(dissect_nmpm1fcp_sysstart, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPSYSSTART_PORT, nmpm1fcp_sysstart_handle);
+
+	nmpm1fcp_hostarqreset_handle = create_dissector_handle(dissect_nmpm1fcp_hostarqreset, proto_nmpm1fcp_special);
+	dissector_add_uint("udp.port", NMPM1FCPHOSTARQRESET_PORT, nmpm1fcp_hostarqreset_handle);
+}
+
+
+static void
+dissect_nmpm1fcp_jtag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGAJTAG");
+	col_add_str(pinfo->cinfo, COL_INFO, "");
+	// nothing yet
+}
+
+static void
+dissect_nmpm1fcp_reset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	guint8 tmp;
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGARESET");
+
+	tmp = tvb_get_guint8(tvb, 0);
+	if (tmp == 0x55) {
+		tmp = tvb_get_guint8(tvb, 3);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "Reset: Core %u FPGADNC %u DDR2 %u DDR2SODIMM %u ARQ %u",
+			tmp>>0 & 0x1,
+			tmp>>1 & 0x1,
+			tmp>>2 & 0x1,
+			tmp>>3 & 0x1,
+			tmp>>4 & 0x1
+		);
+	} else
+		col_add_str(pinfo->cinfo, COL_INFO, "incorrect, wrong magic number");
+}
+
+static void
+dissect_nmpm1fcp_sysstart(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	guint8 tmp;
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGASYSSTART");
+
+	tmp = tvb_get_guint8(tvb, 0);
+	if (tmp == 0x55) {
+		tmp = tvb_get_guint8(tvb, 3);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "SysStart %s", tmp ? "on" : "off");
+	} else if (tmp == 0xc0 && tvb_get_guint8(tvb, 1) == 0x07) {
+		tmp = tvb_get_guint8(tvb, 3);
+		col_add_fstr(pinfo->cinfo, COL_INFO, "SysStart Ack (deprecated): %s", tmp ? "on" : "off");
+	} else
+		col_add_str(pinfo->cinfo, COL_INFO, "incorrect, wrong magic number");
+}
+
+static void
+dissect_nmpm1fcp_hostarqreset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "HostARQ Reset");
+	col_add_str(pinfo->cinfo, COL_INFO, "");
+	/* other stuff was moved to HostARQ Cfg type */
+}
+
+
+
+
+
+
+
+/* payload starting here */
+
+static int proto_nmpm1fcp = -1;
+static gint ett_nmpm1fcp = -1;
+	
+#define FPGACONFIG_PTR       1<<(32-9)
+#define FPGACONFIG_FPL       1<<(32-8)
+#define FPGACONFIG_STC       1<<(32-7)
+#define FPGACONFIG_STP       1<<(32-6)
+#define FPGACONFIG_SOT       1<<(32-5)
+#define FPGACONFIG_STT       1<<(32-4)
+#define FPGACONFIG_STE       1<<(32-3)
+#define FPGACONFIG_CTM       1<<(32-2)
+#define FPGACONFIG_CPM       1<<(32-1)
+
+#define FPGATRACEDATA_FM     1<<(32-1)
+
+static int hf_nmpm1fcp_pdu_fpgaconfig_epl = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_str = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_stc = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_stp = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_sot = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_stt = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_ste = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_ctm = -1;
+static int hf_nmpm1fcp_pdu_fpgaconfig_cpm = -1;
+		
+static int hf_nmpm1fcp_pdu_fpgaplayback_fpgatime = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_fpgacount = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_label = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_timestamp = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_hicanndata = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_hicanntag = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_hicanndest = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_overflow = -1;
+static int hf_nmpm1fcp_pdu_fpgaplayback_trigger = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_dnc = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_hicann = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_tag = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_write = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_read = -1;
+static int hf_nmpm1fcp_pdu_hicanncfgdata_data = -1;
+
+static int hf_nmpm1fcp_pdu_fpgatracedata_timestamp = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_label = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_fm = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_overflow = -1;
+static int hf_nmpm1fcp_pdu_fpgatracedata_flags = -1;
+
+
+
+
+void
+proto_register_nmpm1fcp(void)
+{
+	static hf_register_info hf[] = {
+		{ &hf_hostarq_pdu_type,
+			{ "NMPM1 FCP PDU Type", "nmpm1fcp.type",
+				FT_UINT16, BASE_HEX,
+				VALS(pdutypenames), 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_hostarq_pdu_len,
+			{ "NMPM1 FCP PDU Length", "nmpm1fcp.len",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+		/* FPGACONFIG */
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_str,
+			{ "FPGA Config Start Enable Systime Replace", "fpgaconfig.str",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_PTR,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_epl,
+			{ "FPGA Config Enable Loopback", "fpgaconfig.epl",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_FPL,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_stc,
+			{ "FPGA Config Start Read Traced Configuration", "fpgaconfig.stc",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STC,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_stp,
+			{ "FPGA Config Start Read Traced Pulses", "fpgaconfig.stp",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STP,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_sot,
+			{ "FPGA Config Stop Trace", "fpgaconfig.sot",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_SOT,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_stt,
+			{ "FPGA Config Start Trace", "fpgaconfig.stt",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STT,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_ste,
+			{ "FPGA Config Start Experiment", "fpgaconfig.ste",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_STE,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_ctm,
+			{ "FPGA Config Clear Trace Memory", "fpgaconfig.ctm",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_CTM,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaconfig_cpm,
+			{ "FPGA Config Clear Playback Memory", "fpgaconfig.cpm",
+				FT_BOOLEAN, 32,
+				NULL, FPGACONFIG_CPM,
+				NULL, HFILL }
+		},
+
+
+		/* FPGAPLAYBACK */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_fpgatime,
+			{ "FPGA Playback Data FPGA Time", "fpgaplayback.fpgatime",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_fpgacount,
+			{ "FPGA Playback Data Count", "fpgaplayback.fpgacount",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_label,
+			{ "FPGA Playback Data Label", "fpgaplayback.label",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_timestamp,
+			{ "FPGA Playback Data Timestamp", "fpgaplayback.timestamp",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		/* HICANN Configuration */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_hicanndata,
+			{ "FPGA Playback HICANN Data", "fpgaplayback.hicanndata",
+				FT_UINT64, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_hicanntag,
+			{ "FPGA Playback HICANN Tag", "fpgaplayback.hicanntag",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_hicanndest,
+			{ "FPGA Playback HICANN Dest", "fpgaplayback.hicanndest",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		/* Timestamp Overflow Indicator */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_overflow,
+			{ "FPGA Playback Overflow Indicator", "fpgaplayback.overflow",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		/* Timestamp Overflow Indicator */
+		{ &hf_nmpm1fcp_pdu_fpgaplayback_trigger,
+			{ "FPGA Playback Trigger", "fpgaplayback.trigger",
+				FT_UINT64, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+
+		/* HICANN CFG Data */
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_dnc,
+			{ "HICANN Configuration Data DNC", "hicanncfgdata.dnc",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_hicann,
+			{ "HICANN Configuration Data HICANN", "hicanncfgdata.hicann",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_tag,
+			{ "HICANN Configuration Data Tag", "hicanncfgdata.tag",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_write,
+			{ "HICANN Configuration Data Write", "hicanncfgdata.write",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_read,
+			{ "HICANN Configuration Data Read", "hicanncfgdata.read",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_hicanncfgdata_data,
+			{ "HICANN Configuration Data", "hicanncfgdata.data",
+				FT_UINT64, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+
+		/* Trace Data */
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_timestamp,
+			{ "HICANN Trace Data Timestamp", "fpgatracedata.timestamp",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_label,
+			{ "HICANN Trace Data Label", "fpgatracedata.label",
+				FT_UINT16, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_overflow,
+			{ "HICANN Trace Data Overflow", "fpgatracedata.overflow",
+				FT_UINT32, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_fm,
+			{ "HICANN Trace Data Flags", "fpgatracedata.fm",
+				FT_BOOLEAN, 1,
+				NULL, FPGATRACEDATA_FM,
+				NULL, HFILL }
+		},
+		{ &hf_nmpm1fcp_pdu_fpgatracedata_flags,
+			{ "HICANN Trace Data Flags", "fpgatracedata.flags",
+				FT_UINT8, BASE_DEC,
+				NULL, 0x0,
+				NULL, HFILL }
+		},
+
+	};
+
+	/* Setup protocol subtree array */
+	static gint *ett[] = {
+		&ett_nmpm1fcp
+	};
+
+	proto_nmpm1fcp = proto_register_protocol (
+		"HBP NMPM1 FCP Protocol", /* name       */
+		"NMPM1 FCP",              /* short name */
+		"nmpm1fcp"                /* abbrev     */
+	);
+
+	proto_register_field_array(proto_nmpm1fcp, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+	hostarq_dissector_table = register_dissector_table("nmpm1fcp.type",
+	                                                   "NMPM1 FCP PDU Type",
+	                                                   proto_nmpm1fcp,
+	                                                   FT_UINT16, BASE_HEX);
+}
+
+void
+proto_reg_handoff_nmpm1fcp(void)
+{
+	static dissector_handle_t nmpm1fcp_hostarqcfg_handle;
+	static dissector_handle_t nmpm1fcp_fpgaconfig_handle;
+	static dissector_handle_t nmpm1fcp_fpgaplayback_handle;
+	static dissector_handle_t nmpm1fcp_hicanncfgdata_handle;
+	static dissector_handle_t nmpm1fcp_fpgatracedata_handle;
+
+	nmpm1fcp_hostarqcfg_handle = create_dissector_handle(dissect_nmpm1fcp_hostarqcfg, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", HOSTARQ_CFG, nmpm1fcp_hostarqcfg_handle);
+
+	nmpm1fcp_fpgaconfig_handle = create_dissector_handle(dissect_nmpm1fcp_fpgaconfig, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", FPGACONFIG, nmpm1fcp_fpgaconfig_handle);
+
+	nmpm1fcp_fpgaplayback_handle = create_dissector_handle(dissect_nmpm1fcp_fpgaplayback, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", FPGAPLAYBACK, nmpm1fcp_fpgaplayback_handle);
+
+	nmpm1fcp_hicanncfgdata_handle = create_dissector_handle(dissect_nmpm1fcp_hicanncfgdata, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", HICANNCONFIG, nmpm1fcp_hicanncfgdata_handle);
+	
+	nmpm1fcp_fpgatracedata_handle = create_dissector_handle(dissect_nmpm1fcp_fpgatracedata, proto_nmpm1fcp);
+	dissector_add_uint("nmpm1fcp.type", FPGATRACE, nmpm1fcp_fpgatracedata_handle);
+	// add other dissector foos here
+}
+
+static void
+dissect_nmpm1fcp_hostarqcfg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	guint64 max_nrframes = 0, max_winsiz = 0, max_pduwords = 0;
+	guint offset = 4; // skip typelen
+
+	max_nrframes = tvb_get_ntoh64(tvb, offset);
+	offset += 8;
+	max_winsiz = tvb_get_ntoh64(tvb, offset);
+	offset += 8;
+	max_pduwords = tvb_get_ntoh64(tvb, offset);
+	offset += 8;
+
+	col_set_str(pinfo->cinfo, COL_INFO, "HostARQ Config");
+	col_append_fstr(pinfo->cinfo, COL_INFO,
+					": MAX_NRFRAMES %llu MAX_WINSIZ %llu MAX_PDUWORDS %llu",
+					(long long unsigned) max_nrframes,
+					(long long unsigned) max_winsiz,
+					(long long unsigned) max_pduwords);
+}
+
+
+static void
+dissect_nmpm1fcp_fpgaconfig(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	gint offset = 0;
+	guint32 tmp = 0;
+	
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGACONFIG");
+
+	tmp  = tvb_get_ntohl(tvb, 8); // skip type-len
+	if (tmp) {
+		col_append_str(pinfo->cinfo, COL_INFO, ", ");
+		if (tmp & FPGACONFIG_PTR) col_append_str(pinfo->cinfo, COL_INFO, "PTR ");
+		if (tmp & FPGACONFIG_FPL) col_append_str(pinfo->cinfo, COL_INFO, "FPL ");
+		if (tmp & FPGACONFIG_STC) col_append_str(pinfo->cinfo, COL_INFO, "STC ");
+		if (tmp & FPGACONFIG_STP) col_append_str(pinfo->cinfo, COL_INFO, "STP ");
+		if (tmp & FPGACONFIG_SOT) col_append_str(pinfo->cinfo, COL_INFO, "SOT ");
+		if (tmp & FPGACONFIG_STT) col_append_str(pinfo->cinfo, COL_INFO, "STT ");
+		if (tmp & FPGACONFIG_STE) col_append_str(pinfo->cinfo, COL_INFO, "STE ");
+		if (tmp & FPGACONFIG_CTM) col_append_str(pinfo->cinfo, COL_INFO, "CTM ");
+		if (tmp & FPGACONFIG_CPM) col_append_str(pinfo->cinfo, COL_INFO, "CPM ");
+	}
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *fpgaconfig_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		fpgaconfig_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+		
+		offset += 4; // TYPLEN
+		offset += 4; // upper bits of config frame are unused
+
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_str, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_epl, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_stc, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_stp, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_sot, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_stt, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_ste, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_ctm, tvb, offset, 4, ENC_BIG_ENDIAN);
+		proto_tree_add_item(fpgaconfig_tree, hf_nmpm1fcp_pdu_fpgaconfig_cpm, tvb, offset, 4, ENC_BIG_ENDIAN);
+		// skip second 32-bit entry: it's empty!
+		offset += 8; // end of 8-byte payload entry
+	}
+}
+
+static void
+dissect_nmpm1fcp_fpgaplayback(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	gint offset = 0;
+	gboolean is_data = 0;
+	gboolean is_pulse = 0;
+	gboolean is_overflow = 0;
+	guint32 tmp = 0;
+	guint64 tmp64 = 0;
+	//guint16 type = tvb_get_ntohs(tvb, 0);
+	guint16 len = tvb_get_ntohs(tvb, 2);
+	size_t i = 0, ii = 0;
+	guint16 group_len = 0;
+	
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGAPLAYBACK");
+
+	//pbtype = tvb_get_ntohs(tvb, 4);
+	//if ( ((pbtype & 0x1) == 0) && ((pbtype & (1<<15)) == 0) ) {
+	//	/* Pulse entry */
+	//	tmp = (pbtype & 0x7fff) >> 1; // get lower 15 bits and shift right once
+	//	col_append_fstr(pinfo->cinfo, COL_INFO, " FPGA Time %u", tmp);
+	//	tmp = (tvb_get_ntohs(tvb, 6) & 0x3fff); // lower 14 bits
+	//	col_append_fstr(pinfo->cinfo, COL_INFO, " Count %u", tmp);
+	//}
+	offset += 4;
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *fpgaplayback_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		fpgaplayback_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+
+		// we should check for nodata here!
+
+		for (i = 0; i < len; i++) {
+
+			group_len = (tvb_get_ntohs(tvb, offset+4) >> 2) & 0x3fff;
+			is_data = !((tvb_get_ntohs(tvb, offset+6)) & 0x1);
+			is_pulse = !((tvb_get_ntohs(tvb, offset+4)) & 0x1);
+			is_overflow = !((tvb_get_ntohs(tvb, offset+6)) & 0x2) >> 1;
+
+			if (is_data && is_pulse) {
+				/* Pulse group */
+				i += group_len / 2; // 1 => +0, 2 => +1, 3 => +1, 4 => +2, ...
+
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_label,     tvb, offset* 8+2, 12, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_timestamp, tvb, offset* 8, 15, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgacount, tvb, offset* 8, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgatime,  tvb, offset* 8+1, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+
+				for (ii = 1; ii < group_len; ii++) {
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_label,     tvb, offset* 8+2, 12, ENC_BIG_ENDIAN);
+					offset += 2;
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_timestamp, tvb, offset* 8, 15, ENC_BIG_ENDIAN);
+					offset += 2;
+				}
+				if ((group_len % 2) == 0) // if even, skip 2 bytes padding
+					offset += 2;
+					
+			} else if (is_data && !is_pulse) {
+				/* HICANN configuration */
+				i += group_len;
+
+				offset += 2;
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgacount, tvb, offset* 8, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_fpgatime,  tvb, offset* 8+1, 14, ENC_BIG_ENDIAN);
+				offset += 2;
+
+				for (ii = 0; ii < group_len; ii++) {
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanndest, tvb, offset*8, 5, ENC_BIG_ENDIAN);
+					offset += 1; // 1 byte
+					proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanntag, tvb, offset*8+6, 1, ENC_BIG_ENDIAN);
+					// 7 more bits
+					tmp64    = tvb_get_ntoh64(tvb, offset) & 0xFFFffffFFFFffff; // remaining 49 bits
+					proto_tree_add_uint64_format(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanndata, tvb, offset, 8, tmp64, "HICANN Data: 0x%llx", (long long unsigned)tmp64);
+					//proto_tree_add_uint64(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_hicanndata, tvb, offset, 8, tmp64);
+					offset += 7;
+				}
+			} else if (!is_data && is_overflow) {
+				i += 1;
+				/* Timestamp Overflow Indicator */
+				proto_tree_add_bits_item(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_overflow, tvb, offset*8, 30, ENC_BIG_ENDIAN);
+				offset += 8;
+			} else if (!is_data && !is_overflow) {
+				i += 1;
+				/* Wait for next experiment trigger */
+				proto_tree_add_string(fpgaplayback_tree, hf_nmpm1fcp_pdu_fpgaplayback_trigger, tvb, offset*8+2, 64, "Wait for next experiment");
+				offset += 8;
+			} else {
+				// WTF
+			}
+		}
+	}
+}
+
+static void
+dissect_nmpm1fcp_hicanncfgdata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	//guint16 type = tvb_get_ntohs(tvb, 0);
+	guint16 len = tvb_get_ntohs(tvb, 2);
+	gint offset = 4;
+	size_t ii = 0;
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "HICANNCONFIG");
+
+	//col_append_fstr(pinfo->cinfo, COL_INFO, " DNC %u HICANN %u", (unsigned)dnc, (unsigned)hicann);
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *hicanncfgdata_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		hicanncfgdata_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+	
+		for (ii = 0; ii < len; ii++) { 
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_dnc, tvb, offset*8, 2, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_hicann, tvb, offset*8+2, 3, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_tag,  tvb, offset*8+2+3+9, 1, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_write,  tvb, offset*8+2+3+9+1, 1, ENC_BIG_ENDIAN);
+			proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_read,  tvb, (offset+4)*8, 1, ENC_BIG_ENDIAN);
+			//proto_tree_add_bits_item(hicanncfgdata_tree, hf_nmpm1fcp_pdu_hicanncfgdata_data, tvb, offset*8, 49, ENC_BIG_ENDIAN);
+			offset += 8;
+		}
+	}
+}
+
+static void
+dissect_nmpm1fcp_fpgatracedata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {
+	//guint16 type = tvb_get_ntohs(tvb, 0);
+	guint16 len = tvb_get_ntohs(tvb, 2);
+	gint offset = 4;
+	guint8 tmp = 0;
+	size_t ii = 0;
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "FPGATRACE");
+
+	if (tree) { /* we are being asked for details */
+		proto_item *ti = NULL;
+		proto_tree *fpgatracedata_tree = NULL;
+
+		ti = proto_tree_add_item(tree, proto_nmpm1fcp, tvb, 0, -1, ENC_NA); // consume all, nothing encapsulated here
+		fpgatracedata_tree = proto_item_add_subtree(ti, ett_nmpm1fcp);
+	
+		for (ii = 0; ii < len*2; ii++) { // dword-wise!
+			proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_flags, tvb, offset*8, 2, ENC_BIG_ENDIAN);
+			tmp = tvb_get_guint8(tvb, offset) & 0x3;
+			switch (tmp) {
+				case 0:
+					proto_tree_add_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_fm, tvb, offset, 4, ENC_BIG_ENDIAN);
+					proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_label,     tvb, offset*8+5, 12, ENC_BIG_ENDIAN);
+					offset += 2;
+					proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_timestamp, tvb, offset*8+1, 15, ENC_BIG_ENDIAN);
+					offset += 2;
+					break;
+				case 1:
+					// just padding...
+					proto_tree_add_item(fpgatracedata_tree, tvb, offset, 4, "padding", ENC_UTF_16);
+					offset += 4;
+					break;
+				case 2:
+				case 3:
+					//overflow because higher bit high
+					proto_tree_add_bits_item(fpgatracedata_tree, hf_nmpm1fcp_pdu_fpgatracedata_overflow, tvb, offset*8+1, 31, ENC_BIG_ENDIAN);
+					offset += 4;
+					break;
+				default:
+					break;
+			}
+		}
+	}
+}
+
+#undef HOSTARQ_PORT
+#undef JTAGBULK
+#undef JTAGSINGLE
+#undef I2C
+#undef FPGATRACE
+#undef HICANNREAD
+#undef FPGAPLAYBACK
+#undef FPGAROUTING
+#undef FPGACONFIG
+#undef FPGABWLIMIT
+#undef DNCROUTING
+#undef DNCCONFIG
+#undef HICANNCONFIG
diff --git a/plugins/epan/hostarq/packet-hostarq.h b/plugins/epan/hostarq/packet-hostarq.h
new file mode 100644
index 0000000000..867614cd87
--- /dev/null
+++ b/plugins/epan/hostarq/packet-hostarq.h
@@ -0,0 +1,12 @@
+static int dissect_hostarq(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+static void dissect_nmpm1fcp_jtag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_reset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_sysstart(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_hostarqreset(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+static void dissect_nmpm1fcp_hostarqcfg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_fpgaconfig(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_fpgaplayback(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_hicanncfgdata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+static void dissect_nmpm1fcp_fpgatracedata(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
diff --git a/plugins/epan/hostarq/plugin.rc.in b/plugins/epan/hostarq/plugin.rc.in
new file mode 100644
index 0000000000..568dc07b49
--- /dev/null
+++ b/plugins/epan/hostarq/plugin.rc.in
@@ -0,0 +1,34 @@
+#include "winver.h"
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION @RC_MODULE_VERSION@
+ PRODUCTVERSION @RC_VERSION@
+ FILEFLAGSMASK 0x0L
+#ifdef _DEBUG
+ FILEFLAGS VS_FF_DEBUG
+#else
+ FILEFLAGS 0
+#endif
+ FILEOS VOS_NT_WINDOWS32
+ FILETYPE VFT_DLL
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "CompanyName", "The Wireshark developer community, http://www.wireshark.org/\0"
+            VALUE "FileDescription", "@PACKAGE@ dissector\0"
+            VALUE "FileVersion", "@MODULE_VERSION@\0"
+            VALUE "InternalName", "@PACKAGE@ @MODULE_VERSION@\0"
+            VALUE "LegalCopyright", "Copyright  1998 Gerald Combs <gerald@wireshark.org>, Gilbert Ramirez <gram@alumni.rice.edu> and others\0"
+            VALUE "OriginalFilename", "@PLUGIN_NAME@.dll\0"
+            VALUE "ProductName", "Wireshark\0"
+            VALUE "ProductVersion", "@VERSION@\0"
+            VALUE "Comments", "Build with @MSVC_VARIANT@\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
